\section{A Noisy Half-Adder}
\label{sec:noisy-half-adder}
All operations which change the state of static variables --- either stored in registers or random-access memory (RAM) in a computer --- rely on a special-purpose circuit called the {\em arithmetic logic unit (ALU)}. This digital circuit performs arithmetic and bitwise operations on binary numbers; it is the fundamental building block of the central processing unit (CPU) of computers, floating-point units (FPUs), and even graphics processing units (GPUs) \cite{HamVraZak2012i}. Note that an ALU is not only used for numerical computations on program state variables but also essential for implementing the non-linear process flow in a CPU by virtue of using it to compute the next location in RAM where the program execution continues through arithmetic operations on the so called {\em program counter} (register). Moreover, all arithmetic operations are eventually implemented through simple additions and bit-wise shift operations.

In this section, we are considering the most basic ALU operation which is the addition of two bits $a \in \{0,1\}$ and $b \in \{0,1\}$ with a sum bit $s \in \{0,1\}$ and carry bit $c \in \{0,1\}$ as outputs, respectively. This circuit is called a {\em half-adder} and it essentially computes $s$ as the low bit and $c$ as the high bit of the addition (please see Figure \ref{fig:half-adder} for more details).

\begin{figure}
    \begin{minipage}[c]{.45\linewidth}
        \centering
        \begin{tikzpicture}
            % Circuit style
            \ctikzset{
                logic ports=ieee,
                logic ports/scale=0.8,
                % logic ports/fill=lightgray
            }

            % Logic ports
            \node[or port] (OR) at (0,0){};
            \node[and port] (ANDa) at (0,-3){};
            \node[not port] (NOT) at (2,-3){};
            \node[and port] (ANDb) at (4,-1.5){};

            % Input and output ports
            \node (a) at (-2,-1) [left] {$a$};
            \node (b) at (-2,-2) [left] {$b$};
            \node (c1) at (1,-3) [above] {$c$};
            \node (d) at (1,0) [above] {$d$};
            \node (e) at (2.8,-3) [above] {$e$};
            \node (s) at (5,-1.5) [right] {$s$};
            \node (c2) at (5,-4) [right] {$c$};
            \node (af) [right = 0.5 of a, coordinate] [left] {};
            \node (bf) [right = 1 of b, coordinate] [left] {};

            % % Connection
            \draw (ANDa.out) -- (NOT.in);
            \draw (OR.out) -| (ANDb.in 1);
            \draw (NOT.out) -| (ANDb.in 2);

            \draw (ANDb.out) -* (s);
            \draw (OR.in 1) -| (af) |- (ANDa.in 2);
            \draw (OR.in 2) -| (bf) |- (ANDa.in 1);
            \draw (a) -- (af);
            \draw (b) -- (bf);
            \draw (c1) |- (c2);
        \end{tikzpicture}
    \end{minipage} \hfill
    \begin{minipage}[c]{.5\linewidth}
        \centering
        \begin{tabular}{c|c||c|c|c|c}
            $a$ & $b$ & $c = a \land b$ & $d = a \lor b$ & $e = \neg c$ & $s = d \land e$ \\
            \hline
            $0$ & $0$ & $0$             & $0$            & $1$          & $0$             \\
            $0$ & $1$ & $0$             & $1$            & $1$          & $1$             \\
            $1$ & $0$ & $0$             & $1$            & $1$          & $1$             \\
            $1$ & $1$ & $1$             & $1$            & $0$          & $0$             \\
        \end{tabular}
    \end{minipage}
    \caption{{\bf Left:} Logic circuit design of a half-adder function that computes the sum of two binary numbers $a \in \{0,1\}$ and $b \in \{0,1\}$ where $s$ is the sum of $a$ and $b$ and $c$ captures the carry-bit indicating an overflow (i.e., if $a$ and $b$ are both $1$, then $s=0$ and $c=1$). {\bf Right:} The logical equivalent of the half-adder with the values for all intermediate results $d \in \{0,1\}$ and $e \in \{0,1\}$ for every possible list of (binary) input values. Note that $s = a \mathrm{ xor } b$ and $c = a \land b$. \label{fig:half-adder}}
\end{figure}

\paragraph{Noise Model} We are considering a noise model based on the assumption that the voltage to the actual circuit implementing the logic AND, OR or NOT gate is no longer kept constant resulting in variation of the {\em actual value} of the input to the AND, OR or NOT unit. We assume that the random variation is fully described through two parameters $\alpha \in \left[0,\frac{1}{2}\right]$ and $\beta \in \left[0,\frac{1}{2}\right]$ which denote the probability that a low-voltage input (i.e., bit state of $0$) switches to a high-voltage input (i.e., bit state of $1$) and vice versa\footnote{Note that a flip probability of more than 50\% means that the inverted gate would make less mistakes}. More formally, we assume that
\begin{align}
    P(a_\text{obs} = 1 | a = 0) & = \alpha\,, \label{eq:bit_flip_to_1} \\
    P(a_\text{obs} = 0 | a = 1) & = \beta\,. \label{eq:bit_flip_to_0}
\end{align}
With this noise model, it is possible that an AND, OR or NOT gate make mistakes in their computation. In Table \ref{tab:noisy_and_or_not_gates} we have listed the respective probability of each outcome $0$ and $1$ for the full list of bit-wise inputs $a$ and $b$. 

\begin{table}[ht]
    \centering
    \begin{tabular}{c|c||c|c||c|c||c|c}
        $a$                            & $b$                            &
        $P\left(a \land b = 0\right)$  & $P\left(a \land b = 1\right)$  &
        $P\left(a \lor b = 0\right)$   & $P\left(a \lor b = 1\right)$   &
        $P\left(\neg a = 0\right)$     & $P\left(\neg a = 1\right)$       \\
        \hline
        $0$                            & $0$                            &
        $1-\alpha^2$                   & $\alpha^2$                     &
        $\left(1-\alpha\right)^2$      & $1-\left(1-\alpha\right)^2$    &
        $\alpha$                       & $1-\alpha$                       \\
        $0$                            & $1$                            &
        $1-\alpha\left(1-\beta\right)$ & $\alpha\left(1-\beta\right)$   &
        $\left(1-\alpha\right)\beta$   & $1-\left(1-\alpha\right)\beta$ &
        $\alpha$                       & $1-\alpha$                       \\
        $1$                            & $0$                            &
        $1-\alpha\left(1-\beta\right)$ & $\alpha\left(1-\beta\right)$   &
        $\left(1-\alpha\right)\beta$   & $1-\left(1-\alpha\right)\beta$ &
        $1-\beta$                      & $\beta$                          \\
        $1$                            & $1$                            &
        $1-\left(1-\beta\right)^2$     & $\left(1-\beta\right)^2$       &
        $\beta^2$                      & $1-\beta^2$                    &
        $1-\beta$                      & $\beta$                          \\
    \end{tabular}
    \vspace{1em}
    \caption{Probability distribution of noisy AND gate (column 3 and 4), OR gate (column 5 and 6) and NOT gate (column 7 and 8) based on (\ref{eq:bit_flip_to_1}) and (\ref{eq:bit_flip_to_0}), respectively. Note that it reduces to point functions for $\alpha = \beta = 0$. \label{tab:noisy_and_or_not_gates}}
\end{table}

\paragraph{Noisy Addition}